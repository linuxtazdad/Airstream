lpTag.callback({"taglets":[{"name":"lpTransporter","code":"window.lpTag = window.lpTag || {};\r\nlpTag.taglets = lpTag.taglets || {};\r\n/**\r\n * @fileOverview Contains utilities for the lpajax system - core and transports\r\n *\r\n * @author Efim Dimenstein\r\n * @version 0.1 - 2012-08-20\r\n */\r\n/**\r\n * Contains utilities for the lpajax system - core and transports\r\n *\r\n * @namespace - contains the transport logic\r\n */\r\nlpTag.taglets.lpajax_utils = {\r\n    /**\r\n     * The name of the object\r\n     * @type String\r\n     */\r\n    _name : 'lpajax_utils',\r\n    /**\r\n     * The version of the object\r\n     * @type String\r\n     */\r\n    _v : '0.1',\r\n    /**\r\n     * An `each` implementation, aka `forEach`<br>\r\n     * Handles objects with the built-in `forEach`, arrays, and raw objects<br>\r\n     * Delegates to **ECMAScript 5**'s native `forEach` if available\r\n     *\r\n     * @param {Object} obj list of elements\r\n     * @param {Object} iterator\r\n     * @param {Object} context\r\n     * @example\r\n     * lpTag.taglets.lpajax_utils.each([1, 2, 3], function(num){ alert(num); });\r\n     * result: alerts each number in turn...\r\n     * lpTag.taglets.lpajax_utils.each({one : 1, two : 2, three : 3}, function(num, key){ alert(num); });\r\n     * result: alerts each number in turn...\r\n     */\r\n    each : function(obj, iterator, context) {\r\n        if (obj == null) {return;}\r\n        var nativeForEach = Array.prototype.forEach;\r\n\r\n        if (nativeForEach && obj.forEach === nativeForEach) {\r\n            obj.forEach(iterator, context);\r\n        }\r\n        else if (obj.length === +obj.length) {\r\n            for (var i = 0, l = obj.length; i < l; i++) {\r\n                if (i in obj && iterator.call(context, obj[i], i, obj) === {}) {return;}\r\n            }\r\n        } else {\r\n            for (var key in obj) {\r\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n                    if (iterator.call(context, obj[key], key, obj) === {}) {return;}\r\n                }\r\n            }\r\n        }\r\n    },\r\n    /**\r\n     * Copy all of the properties in the source objects over to the destination object, and return the destination object.<br>\r\n     * It's in-order, so the last source will override properties of the same name in previous arguments\r\n     *\r\n     * @param {Object} obj a request object (see lpAjax for detailed description)\r\n     * @example\r\n     * lpTag.taglets.lpajax_utils.extend(destination, *sources)\r\n     * lpTag.taglets.lpajax_utils.extend({name : 'moe'}, {age : 50});\r\n     * result: {name : 'moe', age : 50}\r\n     */\r\n    extend : function(obj) {\r\n        this.each(Array.prototype.slice.call(arguments, 1), function(source) {\r\n            for (var prop in source) {\r\n                obj[prop] = source[prop];\r\n            }\r\n        });\r\n        return obj;\r\n    },\r\n    /**\r\n     * Method to check if object is empty<br>\r\n     *\r\n     * @param {Object} o any object\r\n     * @returns true if object is empty and false otherwise\r\n     * @example\r\n     * lpTag.taglets.lpajax_utils.isEmptyObj({}) - return true\r\n     * lpTag.taglets.lpajax_utils.isEmptyObj({name : 'moe'}); - return false\r\n     */\r\n    isEmptyObj: function( o ) {\r\n        for (var n in o ) {\r\n            return false;\r\n        }\r\n        return true;\r\n    },\r\n\r\n    init : function(){\r\n\r\n    }\r\n};\r\n\r\nwindow.lpTag = window.lpTag || {};\r\nlpTag.taglets = lpTag.taglets || {};\r\n/**\r\n * lpAjax namespace\r\n * @namespace - contains the lpAjax logic\r\n */\r\nlpTag.taglets.lpAjax = lpTag.taglets.lpAjax || (function (window) {\r\n    var version = \"1.1.3\",\r\n        name = \"lpAjax\",\r\n        containerName = \"lpTransporter\",\r\n        _transports = {},\r\n        isInit = false,\r\n        logTypes = { ERROR: \"ERROR\", DEBUG: \"DEBUG\", INFO: \"INFO\", METRICS:\"METRICS\"},\r\n        rndUID  = \"lpT\" + Math.floor(Math.random() * 100000) + \"_\" + Math.floor(Math.random() * 1000000);\r\n\r\n    function init() {\r\n        isInit = true;\r\n    }\r\n\r\n    function _log(msg, type) {\r\n        if (window.lpTag && lpTag.log) {\r\n            lpTag.log(msg, type, name);\r\n        }\r\n    }\r\n\r\n    function addTransport(name, transport) {\r\n        if(!_transports[name]) {\r\n            _transports[name] = transport;\r\n            _log(\"Added transport: \" + name, logTypes.DEBUG);\r\n        }else{\r\n            _log(\"Existing transport: \" + name + \" tried to register\", logTypes.DEBUG);\r\n        }\r\n    }\r\n\r\n    function issueCall(request) {\r\n        if (!isInit) { init(); }\r\n\r\n        var tname = 'unknown';\r\n\r\n        try {\r\n            var transport = _chooseTransport(request);\r\n            if(transport){\r\n                transport.issueCall(request);\r\n                return true;\r\n            }else{\r\n                _log(\"No Transport found to issueCall\", logTypes.ERROR);\r\n                runCallBack(logTypes.ERROR, request.error, { responseCode: 601, error: \"No Transport found to issueCall, request: \" + request.url, body: \"ERROR\" }, request.context);\r\n            }\r\n        }\r\n        catch (e) {\r\n            if (transport && transport.getName) {\r\n                tname = transport.getName();\r\n            }\r\n            _log(\"Transport - \" + tname + \" - unknown exception while issueCall\", logTypes.ERROR);\r\n            runCallBack(logTypes.ERROR, request.error, { responseCode: 600, error: \"Transport - \" + tname + \" - unknown exception while issueCall: \" + request.url + \" e=\" + e, body: \"ERROR\" }, request.context);\r\n        }\r\n    }\r\n\r\n    function configureTransports(confT) {\r\n        if (!isInit) { init(); }\r\n\r\n        for (var name in confT) {\r\n            var t = _transports[name];\r\n            if (t) {\r\n                t.configure(confT[name]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function publishMetrics(rawDataObj){\r\n        if(rawDataObj && typeof rawDataObj === 'object') {\r\n            rawDataObj.appName = containerName;\r\n            rawDataObj.ts = new Date().getTime();\r\n            if(rawDataObj.tags && rawDataObj.tags.constructor === Array){\r\n                rawDataObj.tags.push({ pageId: rndUID });\r\n            }\r\n            _log(rawDataObj, logTypes.METRICS);\r\n        }\r\n    }\r\n\r\n    function _chooseTransport(reqObj) {\r\n        var foundT = false, index = -1;\r\n        var req;\r\n        for (var i=0; i<reqObj.transportOrder.length; i++) {\r\n            if(!foundT){\r\n                req = extend({} , reqObj);\r\n                var t = _transports[req.transportOrder[i]];\r\n                if (t && t.isValidRequest && t.isValidRequest(req)) {\r\n                    foundT = true;\r\n                    index = i;\r\n                }\r\n            }\r\n        }\r\n        if(foundT){\r\n            return _transports[req.transportOrder[index]];\r\n        }else{\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * An `each` implementation, aka `forEach`<br>\r\n     * Handles objects with the built-in `forEach`, arrays, and raw objects<br>\r\n     * Delegates to **ECMAScript 5**'s native `forEach` if available\r\n     * @param {Object} obj list of elements\r\n     * @param {Object} iterator\r\n     * @param {Object} context\r\n     * @example\r\n     * lpTag.taglets.lpajax_utils.each([1, 2, 3], function(num){ alert(num); });\r\n     * result: alerts each number in turn...\r\n     * lpTag.taglets.lpajax_utils.each({one : 1, two : 2, three : 3}, function(num, key){ alert(num); });\r\n     * result: alerts each number in turn...\r\n     */\r\n     function each(obj, iterator, context) {\r\n        if (obj == null) {return;}\r\n        var nativeForEach = Array.prototype.forEach;\r\n\r\n        if (nativeForEach && obj.forEach === nativeForEach) {\r\n            obj.forEach(iterator, context);\r\n        }\r\n        else if (obj.length === +obj.length) {\r\n            for (var i = 0, l = obj.length; i < l; i++) {\r\n                if (i in obj && iterator.call(context, obj[i], i, obj) === {}) {return;}\r\n            }\r\n        } else {\r\n            for (var key in obj) {\r\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n                    if (iterator.call(context, obj[key], key, obj) === {}) {return;}\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Copy all of the properties in the source objects over to the destination object, and return the destination object.<br>\r\n     * It's in-order, so the last source will override properties of the same name in previous arguments\r\n     *\r\n     * @param {Object} obj a request object (see lpAjax for detailed description)\r\n     * @example\r\n     * lpTag.taglets.lpajax_utils.extend(destination, *sources)\r\n     * lpTag.taglets.lpajax_utils.extend({name : 'moe'}, {age : 50});\r\n     * result: {name : 'moe', age : 50}\r\n     */\r\n     function extend(obj) {\r\n        each(Array.prototype.slice.call(arguments, 1),\r\n            function(source) {\r\n                for (var prop in source) {\r\n                    obj[prop] = source[prop];\r\n                }\r\n            }\r\n        );\r\n        return obj;\r\n    }\r\n\r\n    /**\r\n     * Runs the callback passed protected\r\n     * @param type - the function type for logging purposes\r\n     * @param callback - the function that needs to run\r\n     * @param data - the data passed on to that function\r\n     * @param context - the context if any ti run this in\r\n     */\r\n    function runCallBack(type, callback, data, context) {\r\n        if (typeof callback === 'function') {\r\n            try {\r\n                callback.call(context || null, data);\r\n                callback = null;\r\n            } catch (e) {\r\n                _log(\"runCallback: Exception in execution of callback, type :\" + type + \" e=[\" + e.message + \"]\", logTypes.ERROR);\r\n            }\r\n        } else {\r\n            _log(\"runCallBack: No callback, of type :\" + type, logTypes.INFO);\r\n        }\r\n    }\r\n\r\n\r\n    return {\r\n        getVersion: function () { return version; },\r\n        getName: function () { return name; },\r\n        init : init,\r\n        publishMetrics: publishMetrics,\r\n        issueCall : issueCall,\r\n        configureTransports : configureTransports,\r\n        addTransport : addTransport\r\n    };\r\n})(window);\r\nwindow.lpTag = window.lpTag || {};\r\nlpTag.taglets = lpTag.taglets || {};\r\n/**\r\n * Generic layer for making JSONP requests\r\n * Accepts the following parameters on the requestObject:\r\n * url - request URL, should be the full URL as needed by the server\r\n * encoding - if encoding is needed (default is UTF 8)\r\n * success - method to get called back will always receive the data from the request\r\n * error - a method to call on error\r\n * callback - the parameter name expected in the URL by the replying service\r\n * callbackName -  the name of the function to CREATE. This is for REQUEST CACHING PURPOSES ONLY. IF YOU SUPPLY A REAL FUNCTION IT WILL BE OVERRIDDEN\r\n * retries - if there is no valid response, default is 2\r\n * timeout - default 10 seconds, can be set in seconds\r\n * context - the context we want the succes/error callbacks to run in, if not supplied will be null\r\n */\r\nlpTag.taglets.jsonp = lpTag.taglets.jsonp || (function (window) {//Pass in the window so it's a local variable in the scope\r\n\r\n    var defaults = { //Can be configured with configure public method\r\n            callback: 'cb', //default callback parameter on the URL\r\n            encoding: 'UTF-8',//default encoding for all our requests\r\n            timeout: 10000,//default timeout for unanswered requests\r\n            retries: 2,//default retry for unanswered requests\r\n            metricsCount: 100, //default dump interval of info to lpAjax about request timing\r\n            metricsTimeout : 60000 //Default time to send metrics even if count isn't reached\r\n        },\r\n        logTypes = { ERROR: \"ERROR\", DEBUG: \"DEBUG\", INFO: \"INFO\" },\r\n        initialised = true,\r\n        mURLlen = 2083,//The maximum URL length\r\n        cbPrefix = 'lpCb',//default prefix for all our callbacks\r\n        buffReq = {},//The request buffer for new requests\r\n        callCount = 0,//The total number of calls we've made\r\n        buffReqCount = 0,//The amount of requests in the buffer\r\n        pendReqCount = 0,//The pending requests already made\r\n        refusedCount = 0,//The number of requests refused due to none matching requirements\r\n        errCount = 0,//The error count\r\n        requestStats = [],//The statistical information we have per domain\r\n        errTOid,//The error checking timeout id\r\n        metricsTOId, // The metrics timeout id\r\n        cb = {},//The callback list we have\r\n        callbackSampleLength = _createCallbackName(true).length,\r\n        version = \"1.1.7\",\r\n        transportType = \"jsonp\";\r\n\r\n    /************************ PUBLIC METHODS ***************************/\r\n\r\n    function init() {\r\n        if(lpTag && lpTag.taglets && lpTag.taglets.lpAjax) {\r\n            try{\r\n                lpTag.taglets.lpAjax.addTransport(transportType, publicAPI);\r\n            }catch(exc){}\r\n        }\r\n        _setMetricsTimeout();\r\n    }\r\n\r\n    /**\r\n     * Sets the default configuration we want to use for requests,\r\n     * can be overridden on a request basis\r\n     * properties: callback, encoding, timeout , retries\r\n     * @param configurationObj\r\n     */\r\n    function configure(configurationObj) {\r\n        if (configurationObj) {\r\n            for (var key in configurationObj) {\r\n                if (defaults.hasOwnProperty(key) && configurationObj.hasOwnProperty(key)) {\r\n                    defaults[key] = configurationObj[key];\r\n                }\r\n            }\r\n        }\r\n        init();\r\n    }\r\n\r\n    /**\r\n     * Checks if this transport can handle the request\r\n     * @param reqObj\r\n     * @return {Boolean}\r\n     */\r\n    function isValidRequest(reqObj) {\r\n        var validRequest = false;\r\n        if (initialised && reqObj && reqObj.url) {\r\n            var callbackExists = false;\r\n            if(reqObj.callbackName && typeof reqObj.callbackName === 'string'){\r\n                if(cb[reqObj.callbackName] || window[reqObj.callbackName]){\r\n                    callbackExists = true;\r\n                }\r\n            }\r\n            var totalLength;\r\n            try {\r\n                totalLength = _calculateRequestLength(reqObj);\r\n            } catch (e) {\r\n                _log(\"Could not evaluate the length  of the request, e=\" + e, logTypes.ERROR, \"isValidRequest\");\r\n                validRequest = false;\r\n            }\r\n            if (typeof(totalLength) !== 'undefined' && (totalLength < mURLlen && !callbackExists)) {\r\n                validRequest = true;\r\n            }\r\n        }\r\n        return validRequest;\r\n    }\r\n\r\n    /**\r\n     * Builds the call URL, Buffers the requests and runs requests\r\n     * @param reqObj\r\n     */\r\n    function issueCall(reqObj) {\r\n        var callUrl;\r\n        if (isValidRequest(reqObj)) {\r\n            reqObj = _setRequestDefaults(reqObj);\r\n            if(!reqObj.callbackName || typeof reqObj.callbackName !== 'string'){//Allow to send in a callbackName\r\n                reqObj.callbackName = cbPrefix + _createCallbackName();\r\n            }else{\r\n                reqObj.retries = 0;\r\n            }\r\n            callUrl = reqObj.url + (reqObj.url.indexOf('?') > -1 ? '&' : '?') + reqObj.callback + '=' + '' + reqObj.callbackName;\r\n            if(reqObj.data) {\r\n                callUrl += \"&\" + _convertDataToQueryParams(reqObj.data);\r\n            }\r\n            if(reqObj.query){\r\n                callUrl += \"&\" + _convertDataToQueryParams(reqObj.query);\r\n            }\r\n            reqObj.callUrl = callUrl;\r\n            if (_bufferRequest(reqObj)) {\r\n                _addToCallBackList(reqObj);\r\n                _sendRequests();\r\n            } else {//Log error for URL overflow\r\n                _log(\"URL request was too long and was not sent, url: \" + callUrl, logTypes.ERROR, \"issueCall\");\r\n            }\r\n        } else {\r\n            _log(\"URL request was too long or static callback name already exists, url: \" + callUrl, logTypes.ERROR, \"issueCall\");\r\n            _incrementRefusedCount();\r\n            if (reqObj && reqObj.error) {\r\n                _runCallBack(logTypes.ERROR, reqObj.error, _getErrorResponse(600, \"Transport - JSONP - unable to run request: \" + reqObj.url), reqObj.context);\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets the defaults for the transport\r\n     * @returns {{}}\r\n     */\r\n    function getDefaults(){\r\n        var tDefaults = {};\r\n        for (var defKey in defaults) {\r\n            if (defaults.hasOwnProperty(defKey)) {\r\n                tDefaults[defKey] = defaults[defKey];\r\n            }\r\n        }\r\n        return tDefaults;\r\n    }\r\n\r\n    /************************ PRIVATE METHODS ***************************/\r\n\r\n    /**\r\n     * Sets up the request with default values if they have not been passed in\r\n     * @param reqObj\r\n     */\r\n    function _setRequestDefaults(reqObj) {\r\n        if (typeof reqObj === 'string') {\r\n            var url = reqObj;\r\n            reqObj = { url: url };\r\n        }\r\n        if (!reqObj.url) {\r\n            return false;\r\n        } //nothing to send\r\n\r\n        reqObj.encoding = reqObj.encoding || defaults.encoding;\r\n        reqObj.callback = reqObj.callback || defaults.callback;\r\n        reqObj.retries = typeof reqObj.retries === 'number' ? reqObj.retries : defaults.retries;\r\n        reqObj.timeout = reqObj.timeout ? reqObj.timeout : defaults.timeout;\r\n\r\n        return reqObj;\r\n    }\r\n\r\n    /**\r\n     * Create a callback name that's random every time\r\n     */\r\n    function _createCallbackName(notRandom) {\r\n        var maxValue = 99999, separator = \"x\", cbName;\r\n        if (!notRandom) {\r\n            cbName = Math.round(Math.random() * maxValue) + separator + Math.round(Math.random() * maxValue);\r\n        } else {\r\n            cbName = maxValue + separator + maxValue;\r\n        }\r\n        return cbName;\r\n    }\r\n\r\n    /**\r\n     * Generic method to create error responses\r\n     * @param code\r\n     * @param errorMessage\r\n     * @returns {{statusCode: *, responseCode: *, error: *, body: string}}\r\n     */\r\n    function _getErrorResponse(code, errorMessage){\r\n        return { statusCode: code, responseCode: code, error: errorMessage , body: \"ERROR\" };\r\n    }\r\n\r\n    /**\r\n     * Create a script id tag for the DOM\r\n     */\r\n    function _createScriptId() {\r\n        return \"scr\" + Math.round(Math.random() * 999999999) + '_' + Math.round(Math.random() * 999999999);\r\n    }\r\n\r\n    /**\r\n     * Calculates the URL Length in JSONP.\r\n     * @param reqObj\r\n     * @returns {*}\r\n     * @private\r\n     */\r\n    function _calculateRequestLength(reqObj){\r\n        var callbackNameLength = callbackSampleLength;\r\n\r\n        if(reqObj.callbackName && typeof reqObj.callbackName === 'string'){\r\n            callbackNameLength = reqObj.callbackName.length;\r\n        }\r\n\r\n        return  (4 + (reqObj.callback || defaults.callback).length +\r\n                    reqObj.url.length +\r\n                    callbackNameLength +\r\n                    _convertDataToQueryParams(reqObj.data).length +\r\n                    _convertDataToQueryParams(reqObj.query).length);\r\n    }\r\n\r\n    /**\r\n     * Takes the data parameter and converts it to a query string\r\n     * @param data\r\n     * @return {String}\r\n     */\r\n    function _convertDataToQueryParams(data) {\r\n        var queryString = \"\";\r\n        if (typeof data === 'string') {\r\n            queryString += data;\r\n        } else {\r\n            var first = true;\r\n            for (var key in data) {\r\n                var value;\r\n                if (typeof data[key] == 'object') {\r\n                    value = _stringify(data[key]);\r\n                } else if (typeof data[key] !== 'function') {\r\n                    value = data[key];\r\n                }\r\n                if (typeof value !== \"undefined\") {\r\n                    if (!first) {\r\n                        queryString += \"&\";\r\n                    }\r\n                    queryString += encodeURIComponent(key) + \"=\" + encodeURIComponent(value);\r\n                    first = false;\r\n                }\r\n            }\r\n        }\r\n        return queryString;\r\n    }\r\n\r\n    /**\r\n     * This function was added because of incompatibility between the JSON.stringify and Prototype.js library\r\n     * When a costumer uses Prototype.js library, It overrides the Array.prototype.toJSON function the the native JSON\r\n     * uses. This causes arrays to be double quoted and Shark to fail on those SDEs.\r\n     * The function accepts a value and and uses the native JSON.stringify\r\n     * Can throw an exception (same as JSON.stringify).\r\n     */\r\n    function _stringify(value) {\r\n        var stringified;\r\n        if (typeof Array.prototype.toJSON === 'function') {\r\n            var toJSONPrototype = Array.prototype.toJSON;\r\n            delete Array.prototype.toJSON;\r\n            try {\r\n                stringified = JSON.stringify(value);\r\n            } catch (e) {\r\n                Array.prototype.toJSON = toJSONPrototype;\r\n                throw e;\r\n            }\r\n            Array.prototype.toJSON = toJSONPrototype;\r\n        } else {\r\n            stringified = JSON.stringify(value);\r\n        }\r\n        return stringified;\r\n    }\r\n\r\n    /**\r\n     * Buffers requests according to subDomain to insure we don't overflow the browser\r\n     * @param reqObj\r\n     */\r\n    function _bufferRequest(reqObj) {\r\n        var validRequest = false;\r\n        var domainRegEx = new RegExp(/(http{1}s{0,1}?:\\/\\/)([^\\/\\?]+)(\\/?)/ig);\r\n        var matches;\r\n        if (reqObj.callUrl.indexOf(\"http\") === 0) {\r\n            matches = domainRegEx.exec(reqObj.callUrl);\r\n        } else {\r\n            matches = domainRegEx.exec(window.location.href);\r\n        }\r\n        if (matches && matches.length >= 3 && matches[2] !== \"\") {\r\n            var domain = matches[2].toLowerCase(); // 0 - full match 1- HTTPS 2- domain\r\n            reqObj.domainMatch = domain;\r\n            buffReq[domain] = buffReq[domain] || [];\r\n            buffReq[domain].inFlight = buffReq[domain].inFlight || 0;\r\n            buffReq[domain].push(reqObj);\r\n            validRequest = true;\r\n            buffReqCount = buffReqCount + 1;\r\n            _log('buffered URL: ' + reqObj.callUrl, logTypes.DEBUG, 'lpTag.taglets.jsonp.bufferRequest');\r\n        } else {\r\n            _log('NO MATCH for URL: ' + reqObj.callUrl, logTypes.ERROR, 'lpTag.taglets.jsonp.bufferRequest');\r\n        }\r\n        return validRequest;\r\n    }\r\n\r\n    /**\r\n     * Checks the buffer and sends requests according to available net slots\r\n     */\r\n    function _sendRequests() {\r\n        var currentSubDomain;\r\n        for (var subDomain in buffReq) {\r\n            if (buffReq.hasOwnProperty(subDomain)) {\r\n                currentSubDomain = buffReq[subDomain];\r\n                var breakLoop = false;\r\n                while (!breakLoop && currentSubDomain.inFlight < 6 && currentSubDomain.length > 0) {\r\n                    var request = currentSubDomain.shift();\r\n                    if (request) {\r\n                        _log('Sent URL: ' + request.callUrl, logTypes.DEBUG, 'lpTag.taglets.jsonp.sendRequests');\r\n                        request.scriptId = _makeScriptCall(request.callUrl, request.encoding, request.callbackName);\r\n                        request.startTime =  new Date().getTime();\r\n                        _incrementCallCounts(subDomain, request.callbackName, request.timeout);\r\n                        buffReqCount = buffReqCount - 1;\r\n                    } else {\r\n                        breakLoop = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        currentSubDomain = null;\r\n    }\r\n\r\n    /**\r\n     * Checks for timed out requests that are pending and functions which were kept to prevent errors on the page\r\n     */\r\n    function _checkForErrors() {\r\n        clearTimeout(errTOid);\r\n        errTOid = null;\r\n        var now = new Date();\r\n        for (var key in cb) {//Check for requests taking too long\r\n            if (cb.hasOwnProperty(key) && cb[key].launchTime) {\r\n                var timeElapsed = now - cb[key].launchTime;\r\n                if (cb[key].loadTime || timeElapsed > cb[key].timeout) {//Call error callBack\r\n                    window[key].apply(null, [\r\n                        _getErrorResponse(408, { message: \"Request timed out\", name: \"timeout\" }),\r\n                        true\r\n                    ]);//true here signals error will be called back\r\n                }\r\n            }\r\n        }\r\n\r\n        if (pendReqCount > 0) {\r\n            errTOid = setTimeout(_checkForErrors, 1000);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates the script tag for the request and returns the scriptId on the page\r\n     * @param URL\r\n     * @param encoding\r\n     */\r\n    function _makeScriptCall(URL, encoding, callbackName) {\r\n        var scriptId = _createScriptId();\r\n        var scriptCall = document.createElement(\"script\");\r\n        scriptCall.setAttribute(\"type\", \"text/javascript\");\r\n        scriptCall.setAttribute(\"charset\", encoding);\r\n        //These binds are to listen to script load time to lower error notification time for failed scripts\r\n        //Note this will only work for requests that end with .js\r\n        scriptCall.onload = function () {//Try for all browsers, should never have negative impact\r\n            if(cb[callbackName]){\r\n                cb[callbackName].loadTime = new Date();\r\n            }\r\n            this.onload = this.onerror = this.onreadystatechange = null;\r\n        };\r\n        if(!window.addEventListener){//Mainly for IE, since IE8- do not supply onerror handlers\r\n            scriptCall.onreadystatechange = function(){\r\n                if (this.readyState) {\r\n                    if(this.readyState === \"loaded\" || this.readyState === \"complete\"){\r\n                        if(cb[callbackName]){\r\n                            cb[callbackName].loadTime = new Date();\r\n                        }\r\n                        this.onload = this.onerror = this.onreadystatechange = null;\r\n                    }\r\n                }\r\n            };\r\n        }else{\r\n            //All other browsers support this normalized behavior\r\n            scriptCall.onerror = function(){\r\n                if(cb[callbackName]){\r\n                    cb[callbackName].loadTime = new Date();\r\n                }\r\n                this.onload = this.onerror = this.onreadystatechange = null;\r\n            };\r\n        }\r\n        scriptCall.setAttribute(\"src\", URL);\r\n        scriptCall.setAttribute(\"id\", scriptId);\r\n        document.getElementsByTagName(\"head\")[0].appendChild(scriptCall);\r\n        if (!errTOid) {\r\n            errTOid = setTimeout(_checkForErrors, 1000);\r\n        }\r\n        scriptCall = null;\r\n        return scriptId;\r\n    }\r\n\r\n    /**\r\n     * Increments the counters on the correct domain and general request counter\r\n     * @param domainMatch\r\n     * @param callbackName\r\n     * @param timeout\r\n     */\r\n    function _incrementCallCounts(domainMatch, callbackName, timeout) {\r\n        buffReq[domainMatch].inFlight = buffReq[domainMatch].inFlight + 1;\r\n        cb[callbackName] = { launchTime: new Date(), timeout: timeout };\r\n        pendReqCount = pendReqCount + 1;\r\n        callCount = callCount + 1;\r\n    }\r\n\r\n    /**\r\n     * Increments the counter of calls we can't make\r\n     */\r\n    function _incrementRefusedCount(){\r\n        refusedCount = refusedCount + 1;\r\n    }\r\n\r\n    /**\r\n     * Removes the script tag for the request\r\n     * @param scriptId\r\n     */\r\n    function _removeScript(scriptId) {\r\n        //Lesson learned from: http://neil.fraser.name/news/2009/07/27/\r\n        var scriptTag = document.getElementById(scriptId);\r\n        if (scriptTag) {\r\n            try {\r\n                scriptTag.parentNode.removeChild(scriptTag);\r\n                for (var key in scriptTag) {\r\n                    //No garbage collection for the tag, so we delete all it's properties\r\n                    if (scriptTag.hasOwnProperty(key)) {\r\n                        delete scriptTag[key];\r\n                    }\r\n                }\r\n            } catch (exc) {\r\n                _log(\"error when removing script\", logTypes.ERROR, \"removeScript\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Decrements the call counters in this layer\r\n     */\r\n    function _decrementRequestCount(domainMatch) {\r\n        buffReq[domainMatch].inFlight = buffReq[domainMatch].inFlight - 1;\r\n        pendReqCount = pendReqCount - 1;\r\n    }\r\n\r\n    /**\r\n     * Callback for all requests, runs cleanup and executes passed in methods\r\n     * @param data\r\n     * @param reqObj\r\n     * @param isError\r\n     * @private\r\n     */\r\n    function _defaultCallBack(data, reqObj, isError) {\r\n        _addToStats(reqObj.startTime, reqObj.url, isError);\r\n        _removeScript(reqObj.scriptId); //Clear the DOM of the script call\r\n        _decrementRequestCount(reqObj.domainMatch);\r\n        _removeFromCallbacksList(reqObj.callbackName, isError);\r\n        if (isError) {//Decides if there is an error here\r\n            if(reqObj.callbackName){\r\n                reqObj.callbackName = null;\r\n                delete reqObj.callbackName;\r\n            }\r\n            _errorCallback(data, reqObj);\r\n        } else {\r\n            _cleanupCallParameters(reqObj);\r\n            _runCallBack(\"callback\", reqObj.success, data, reqObj.context);\r\n            reqObj = null;\r\n            _sendRequests();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Publishes stats to lpAjax to decide if we want to report this\r\n     */\r\n    function _publishMetrics(){\r\n        var res;\r\n        if(lpTag.taglets.lpAjax &&\r\n            lpTag.taglets.lpAjax.publishMetrics &&\r\n            requestStats.length > 0){\r\n            res = {\r\n                tags: [ { transport: transportType } ],\r\n                metrics : requestStats\r\n            };\r\n            lpTag.taglets.lpAjax.publishMetrics(res);\r\n            requestStats.length = 0;\r\n        }\r\n        _setMetricsTimeout();\r\n    }\r\n\r\n    /**\r\n     * Clears any previous timeout to set this data and sets up\r\n     * the next time this should happen\r\n     */\r\n    function _setMetricsTimeout(){\r\n        if(metricsTOId) {\r\n            clearTimeout(metricsTOId);\r\n        }\r\n        metricsTOId = setTimeout(_publishMetrics, defaults.metricsTimeout);\r\n    }\r\n\r\n    /**\r\n     * Adding the time spent on the request\r\n     * @param startTime\r\n     */\r\n    function _addToStats(startTime, url, isError){\r\n        var requestDuration, now;\r\n        if(startTime) {\r\n            now = new Date().getTime();\r\n            requestDuration = (now - startTime);\r\n            requestStats.push({\r\n                rd: requestDuration,\r\n                ts: startTime,\r\n                url :url,\r\n                method: \"GET\",\r\n                statusCode: isError ? 400 : 200\r\n            });\r\n\r\n            if(requestStats.length >= defaults.metricsCount) {\r\n                _publishMetrics();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Error callback for all requests, runs cleanup and executes passed in methods\r\n     * @param reqObj\r\n     */\r\n    function _errorCallback(errorData, reqObj) {\r\n        errCount = errCount + 1;\r\n        if (reqObj.retries > 0) {//Set up another attempt at calling this URL\r\n            reqObj.retries = reqObj.retries - 1;\r\n            issueCall(reqObj);\r\n        } else {//Notify of failure\r\n            _cleanupCallParameters(reqObj);\r\n            _runCallBack(logTypes.ERROR, reqObj.error, errorData || _getErrorResponse(408, { id: 408, name: \"TIMEOUT\", message: \"Request has timed out on all retries\" }), reqObj.context);\r\n            reqObj = null;\r\n            _sendRequests();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Cleans up parameters from the request object\r\n     * @param reqObj\r\n     */\r\n    function _cleanupCallParameters(reqObj) {\r\n        var addedParams = [\"callUrl\", \"retries\", \"id\", \"requestTimeout\", \"type\", \"encoding\", \"launchTime\", \"callbackName\", \"domainMatch\", \"startTime\"];\r\n        for (var i = 0; i < addedParams.length; i++) {\r\n            if (reqObj.hasOwnProperty(addedParams[i])) {\r\n                reqObj[addedParams[i]] = null;\r\n                delete reqObj[addedParams[i]];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Runs the callback passed protected\r\n     * @param type - the function type for logging purposes\r\n     * @param callback - the function that needs to run\r\n     * @param data - the data passed on to that function\r\n     * @param context - the context if any ti run this in\r\n     */\r\n    function _runCallBack(type, callback, data, context) {\r\n        if (typeof callback === 'function') {\r\n            try {\r\n                callback.call(context || null, data);\r\n                callback = null;\r\n            } catch (e) {\r\n                _log(\"Exception in execution of callback, type :\" + type + \" e=[\" + e.message + \"]\", logTypes.ERROR, \"runCallback\");\r\n            }\r\n        } else {\r\n            _log(\"No callback, of type :\" + type, logTypes.INFO, \"runCallback\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes callback from the list, in case of error we set the function with a new function to prevent errors on page\r\n     * @param callbackName - the callback to remove from the queue\r\n     * @param error - if this is because of an error (to set up a protection function on page)\r\n     */\r\n    function _removeFromCallbacksList(callbackName, error) {\r\n        cb[callbackName] = null;\r\n        delete cb[callbackName];\r\n        if (error === true) {\r\n            window[callbackName] = function () {//Function to clear itself - prevents errors being thrown on page\r\n                window[callbackName] = null;\r\n                try {\r\n                    delete window[callbackName];\r\n                } catch (err) {}\r\n            };\r\n        } else {\r\n            window[callbackName] = null;\r\n            try {\r\n                delete window[callbackName];\r\n            } catch (err) {\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a closure scope to keep the object reference to the defaukt function\r\n     * @param reqObj\r\n     */\r\n    function _addToCallBackList(reqObj) {\r\n        if(cb[reqObj.callbackName]){\r\n            _incrementRefusedCount();\r\n            _errorCallback(_getErrorResponse(409, { message: \"This callbackName is already in a pending request and can't be serviced\", id: 409, name: \"CONFLICT\" }), reqObj);\r\n        }else{\r\n            window[reqObj.callbackName] = function (data, error) {\r\n                _defaultCallBack(data, reqObj, error);\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Passes a log to lpTag\r\n     * @param msg\r\n     * @param type\r\n     * @param callingObj\r\n     */\r\n    function _log(msg, type, callingObj) {\r\n        if (window.lpTag && lpTag.log) {\r\n            if(typeof msg === 'string' && callingObj){\r\n                msg = callingObj + ': ' + msg;\r\n            }\r\n            lpTag.log(msg, type, transportType);\r\n        }\r\n    }\r\n\r\n\r\n    var publicAPI =  {//These are the exposed public methods of this SINGLETON\r\n        init: init,\r\n        configure: configure,\r\n        issueCall: issueCall,\r\n        isValidRequest: isValidRequest,\r\n        getVersion: function () { return version; },\r\n        getName: function () { return transportType; },\r\n        getDefaults: getDefaults,\r\n        inspect: function () {\r\n            return {\r\n                name: transportType,\r\n                version: version,\r\n                callsMade: callCount,\r\n                errorsFound: errCount,\r\n                pending: pendReqCount,\r\n                buffered: buffReqCount,\r\n                refused: refusedCount ,\r\n                defaults: getDefaults()\r\n            };\r\n        }\r\n    };\r\n\r\n    /************************ Execution ***************************/\r\n    init();\r\n\r\n    return publicAPI;\r\n})(window);\r\n\r\nwindow.lpTag = window.lpTag || {};\r\nlpTag.taglets = lpTag.taglets || {};\r\n\r\nlpTag.taglets.postmessage = lpTag.taglets.postmessage || (function (window) {\r\n\r\n    var version = \"1.1.8\",\r\n        transportType = \"postmessage\",\r\n        initialised = true,\r\n        iFramesObj = {},\r\n        callbacks = {},\r\n        pendingFrameReqQueue = {},\r\n        callCount = 0,\r\n        errorCount = 0,\r\n        pendingCount = 0,\r\n        iFrameList = {},\r\n        errorTimeOutId,\r\n        windowLoaded = false,\r\n        iFrameAttachPendingQueue = [],\r\n        logType = { DEBUG: \"DEBUG\", INFO: \"INFO\", ERROR:\"ERROR\"},\r\n        docSubDomain = _getSubDomain(document.location.href),\r\n        responseTypes  = { progress: \"progressLoad\", completed: \"completeLoad\", success: \"success\", error: \"errorLoad\", reloading: \"reloading\", stats: \"statData\" },\r\n        postMessageTimeout = { responseType: responseTypes.error, responseCode: 404, message: \"Request timed out on parent postMessage layer\", name: \"TIMEOUT\"},\r\n        iFrameLoaded = { responseType: responseTypes.success, responseCode: 200, message: \"iFrame has successfully loaded\", name: \"OK\"},\r\n        iFrameTeapot = { responseType: responseTypes.error, responseCode: 418, message: \"This iFrame is a teapot, not very useful for communication but lovely for earl grey\", name: \"TEAPOT\" },//See rfc http://www.ietf.org/rfc/rfc2324.txt\r\n        rDefaults = { timeout: 60000, metricsCount: 1000},\r\n        iFrameOnLoadTimeout = 10000,\r\n        validationState = {//Enumeration of the possible iFrame states\r\n            VALIDATED: \"valid\",\r\n            PENDING: \"pending\",\r\n            FAILED: \"failed\"\r\n        };\r\n\r\n    /*************************** AUTO EXECUTE **********************************/\r\n\r\n    _setParentLoadedState();\r\n\r\n    _bindEvent(window, \"message\", _handleMessage);\r\n\r\n    /************************** PUBLIC METHODS **********************************/\r\n\r\n    /**\r\n     * Initialising method\r\n     * Sets defaults on the parent trans port\r\n     * Allows passing an iFrame objects for later use with configuration as objects, format:\r\n     * frames: { url: IFRAME_LOCATION, defaults: DEFAULT_CONFIGURATION_FOR_XHR }\r\n     * @param configurationObj\r\n     */\r\n    function configure(configurationObj) {\r\n        var isHttps = (location.protocol.indexOf(\"https\") === 0);\r\n        if (configurationObj) {\r\n            if (configurationObj.frames) {\r\n                configurationObj.frames = configurationObj.frames.constructor === Array ? configurationObj.frames : [configurationObj.frames];\r\n                for (var i = 0; i < configurationObj.frames.length; i++) {\r\n                    _queueFrame(configurationObj.frames[i], isHttps);\r\n                }\r\n            }\r\n            if (configurationObj.defaults) {\r\n                for (var key in configurationObj.defaults) {\r\n                    if (rDefaults.hasOwnProperty(key) && configurationObj.defaults.hasOwnProperty(key)) {\r\n                        rDefaults[key] = configurationObj.defaults[key];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        initialised = true;\r\n    }\r\n\r\n    function init() {\r\n        if(lpTag && lpTag.taglets && lpTag.taglets.lpAjax) {\r\n            try{\r\n                lpTag.taglets.lpAjax.addTransport(transportType, publicAPI);\r\n            }catch(exc){}\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates the request can be handled by this transport\r\n     * Checks that an iframe exists or one is pending validation\r\n     * for the sub-domain of the request\r\n     * @param msgObj\r\n     * @return {Boolean}\r\n     */\r\n    function isValidRequest(msgObj) {\r\n        var validRequest = false;\r\n        if (window.postMessage && window.JSON){//we need both to be able to run a request\r\n            if (msgObj && msgObj.success && ((msgObj.domain && msgObj.validation) || msgObj.url)) {\r\n                msgObj.domain = msgObj.domain || _getSubDomain(msgObj.url);\r\n                if (iFramesObj[msgObj.domain] || iFrameList[msgObj.domain]) {\r\n                    validRequest = true;\r\n                }\r\n            }\r\n        }\r\n        return validRequest;\r\n    }\r\n\r\n    /**\r\n     * Issues a call to the domain requested by passing the request to the child iFrame if a validated iFrame exists\r\n     * If an iFrame was configured but never used it triggers it's addition and queues the callback\r\n     * If an iFrame was started but is pending validation, it queues the request for when the frame is validated\r\n     * @param msgObj\r\n     * @return {Boolean}\r\n     */\r\n    function issueCall(msgObj) {\r\n        var messageSent = false;\r\n        if (initialised && isValidRequest(msgObj)) {\r\n            if (iFramesObj[msgObj.domain]) {\r\n                if (iFramesObj[msgObj.domain].validated === validationState.PENDING && !msgObj.validation) {\r\n                    messageSent = _queueForFrame(msgObj.domain, msgObj);\r\n                } else {\r\n                    messageSent = _sendRequest(msgObj);\r\n                    if (messageSent) {\r\n                        _incrementCallCounters(msgObj.domain);\r\n                    }else{//If message was not sent, we invoke immediate timeout\r\n                        callbacks[msgObj.callId].timeout = 0;\r\n                    }\r\n                }\r\n            } else {\r\n                _log(\"Adding iFrame to DOM - first request: \" + msgObj.domain,  logType.INFO , \"issueCall\");\r\n                messageSent = _queueForFrame(msgObj.domain, msgObj);//Queue the callback for this frame\r\n                _addFrame(iFrameList[msgObj.domain]);\r\n                delete iFrameList[msgObj.domain];//remove from our pending for use list\r\n            }\r\n        } else {\r\n            messageSent = _noFrameFound(msgObj.domain, msgObj.error, msgObj.context);\r\n        }\r\n        return messageSent;\r\n    }\r\n\r\n    /**\r\n     * Method for querying info about a specific iFrame state\r\n     * @param domain\r\n     * @return {*}\r\n     */\r\n    function getFrameData(domain) {\r\n        if(domain && iFramesObj[domain]) {\r\n            return {\r\n                url: iFramesObj[domain].url,\r\n                validated: iFramesObj[domain].validated,\r\n                requestCount: iFramesObj[domain].requestCount,\r\n                defaults: _cloneSimpleObj(iFramesObj[domain].defaults),\r\n                started: iFramesObj[domain].validated === validationState.VALIDATED\r\n            };\r\n        }else{\r\n            return {};\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a list of active iFrames and their state (uses getFrameData)\r\n     * @return {Object}\r\n     */\r\n    function getAllFramesData() {\r\n        var framesResult = {};\r\n        for (var key in iFramesObj) {\r\n            if (iFramesObj.hasOwnProperty(key)) {\r\n                framesResult[key] = getFrameData(key);\r\n            }\r\n        }\r\n        return framesResult;\r\n    }\r\n\r\n    /************************** PRIVATE METHODS **********************************/\r\n\r\n    /**\r\n     * Binding function for DOM elements\r\n     * @param elem - the element we're binding to\r\n     * @param eventName - the event we're listening on\r\n     * @param callback - our callback for when it happens\r\n     */\r\n    function _bindEvent(elem, eventName, callback) {\r\n        if (elem.addEventListener) {\r\n            elem.addEventListener(eventName, callback, false);\r\n        } else {\r\n            elem.attachEvent(\"on\" + eventName, callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new error response object\r\n     * @param callId\r\n     * @param responseObj\r\n     * @return {Object}\r\n     */\r\n    function _getErrorResponse(callId, responseObj){\r\n        return { callId: callId, responseType: responseObj.responseType, responseCode: responseObj.responseCode, error: { message: responseObj.message, id: responseObj.responseCode, name: responseObj.name}};\r\n    }\r\n\r\n    /**\r\n     * Unbinds a DOM event\r\n     * @param elem\r\n     * @param eventName\r\n     * @param callback\r\n     */\r\n    function _unbindEvent(elem, eventName, callback) {\r\n        if (elem.removeEventListener) {\r\n            elem.removeEventListener(eventName, callback, false);\r\n        } else if(elem.detachEvent){\r\n            elem.detachEvent(\"on\" + eventName, callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the current state so we can understand what to in case of\r\n     * someone trying to add the frame to the body before it's interactive\r\n     */\r\n    function _setParentLoadedState(){\r\n        if(document.body){\r\n            windowLoaded = true;\r\n            _attachPendingIFrames();\r\n        }else{\r\n            setTimeout(_setParentLoadedState, 5);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Runs the pending iFrame attachments to the body of not yet loaded iFrames\r\n     */\r\n    function _attachPendingIFrames(){\r\n        while(iFrameAttachPendingQueue.length > 0){\r\n            try{\r\n                (iFrameAttachPendingQueue.shift()).call(null);\r\n            }catch (exc){\r\n                _log(\"Unable to execute queued callbacks for window interactive state: \" + exc, logType.ERROR, \"_attachPendingIFrames\" );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a Unique identifier with a prefix\r\n     * @return {String}\r\n     */\r\n    function _createUId(preFix) {\r\n        return preFix + \"_\" + Math.floor(Math.random() * 100000) + \"_\" + Math.floor(Math.random() * 100000);\r\n    }\r\n\r\n    /**\r\n     * Function to extract the sub domain from any URL\r\n     * @param url\r\n     * @return {String}\r\n     */\r\n    function _getSubDomain(url) {\r\n        var domainRegEx = new RegExp(/(http{1}s{0,1}?:\\/\\/)([^\\/\\?]+)(\\/?)/ig);\r\n        var matches, domain = null;\r\n        if (url.indexOf(\"http\") === 0) {\r\n            matches = domainRegEx.exec(url);\r\n        } else {//This is a partial url so we assume it's relative, this is mainly nice for tests\r\n            return location.protocol + \"//\" + location.host;\r\n        }\r\n        if (matches && matches.length >= 3 && matches[2] !== \"\") {\r\n            domain = matches[1].toLowerCase() + matches[2].toLowerCase(); // 0 - full match 1- HTTPS 2- domain\r\n        }\r\n        return domain;\r\n    }\r\n\r\n    /**\r\n     * Adds an iFrame to our list of potential iFrames\r\n     * Also checks for defaults definition of requests for that iFrame\r\n     * If none existent sets the defaults defined for the transport\r\n     * @param frameObject\r\n     * @param parentIsHttps\r\n     * @return {Boolean}\r\n     */\r\n    function _queueFrame(frameObject, parentIsHttps) {\r\n        var added = false, domain, isHttps;\r\n        if (!frameObject || !frameObject.url || typeof frameObject.url !== 'string') {\r\n            _log(\"iFrame configuration empty or missing url parameter\", logType.ERROR, \"_queueFrame\");\r\n            return added;\r\n        }\r\n        domain = _getSubDomain(frameObject.url);\r\n        isHttps = (frameObject.url.toLowerCase().indexOf(\"https\") === 0);\r\n        if (!iFramesObj[domain] && !iFrameList[domain]) {\r\n            if(!parentIsHttps || (isHttps === parentIsHttps)){//This is to protect from adding http iframes to pages that are https, something the browser itself will block\r\n                iFrameList[domain] = frameObject;\r\n                added = true;\r\n            }\r\n        }\r\n        return added;\r\n    }\r\n\r\n    /**\r\n     * Adds the frame to the DOM and queues a listener\r\n     * To know if it has loaded\r\n     * @param iFrameConfiguration\r\n     *   src - the URL for the iframe\r\n     *   defaults  - the default configuration for this iFrame\r\n     *   success/callback - the validation callback supplied from externally\r\n     *   context - the execution context for the external callback\r\n     *   delayLoad - if the frame should be loaded with timeout (for refresh scenarios where other scripts need to run before)\r\n     *   error - callback in case the iFrame dies\r\n     * @return {*}\r\n     */\r\n    function _addFrame(iFrameConfiguration) {\r\n        //url, defaults, callback ||  success, context, delayLoad, error\r\n        var domain = _getSubDomain(iFrameConfiguration.url);\r\n        if (iFramesObj[domain]) {\r\n            return _frameExists(domain, iFrameConfiguration.callback || iFrameConfiguration.success, iFrameConfiguration.context);\r\n        }\r\n        var id = _createUId(\"fr\");\r\n\r\n        iFramesObj[domain] = {\r\n            elem: _createiFrame(id),//The iFrame element on the page\r\n            url: iFrameConfiguration.url,//The iFrame src URL\r\n            validated: validationState.PENDING,//The validation state\r\n            defaults: iFrameConfiguration.defaults || {},//Defaults for this iFrame\r\n            delayLoad: isNaN(iFrameConfiguration.delayLoad) ? 0:  iFrameConfiguration.delayLoad,//Delayload configuration for adding to DOM, default is end of queue\r\n            requestCount: 0,//The number of requests issued to this iFrame\r\n            success: iFrameConfiguration.callback || iFrameConfiguration.success,//The callback when the frame has loaded\r\n            error: iFrameConfiguration.error,//An error callback when the frame is dead\r\n            maxReloadRetries: iFrameConfiguration.maxReloadRetries || 3,//The number of tries to revive this iFrame\r\n            reloadInterval: iFrameConfiguration.reloadInterval * 1000 || 30000//The timeout between reload intervals\r\n        };\r\n\r\n        setTimeout(function () {//Always timed out for best compatablity\r\n            _addFrameToBodyAndBind(iFrameConfiguration.url , domain);\r\n        }, iFramesObj[domain].delayLoad);\r\n        _log(\"iFrame Queued to load \" +  domain , logType.INFO, \"_addFrame\");\r\n        return validationState.PENDING;\r\n    }\r\n\r\n    function _returnFrameToList(iFrameConfiguration) {\r\n        var domain = _getSubDomain(iFrameConfiguration.url);\r\n        iFrameList[domain] = {\r\n            url: iFrameConfiguration.url,//The iFrame src URL\r\n            defaults: iFrameConfiguration.defaults || {},//Defaults for this iFrame\r\n            delayLoad: iFrameConfiguration.delayLoad,//Delayload configuration for adding to DOM, default is end of queue\r\n            success: iFrameConfiguration.success,//The callback when the frame has loaded\r\n            error: iFrameConfiguration.error,//An error callback when the frame is dead\r\n            maxReloadRetries: iFrameConfiguration.maxReloadRetries,//The number of tries to revive this iFrame\r\n            reloadInterval: iFrameConfiguration.reloadInterval / 1000//The timeout between reload intervals\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Adds the iframe to the DOM, sets the URL and starts the validation process\r\n     * @param src - the iframe URL\r\n     * @param domain - the domain of this URL\r\n     */\r\n    function _addFrameToBodyAndBind(src, domain) {\r\n        if(windowLoaded){\r\n            _attachFrame(src, domain);\r\n        }else{\r\n            iFrameAttachPendingQueue.push(function(){\r\n                _attachFrame(src, domain);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attaches the iFrame to the body and binds to it's onload event\r\n     * @param src\r\n     * @param domain\r\n     */\r\n    function _attachFrame(src, domain){\r\n        iFramesObj[domain].loadCallback = iFramesObj[domain].loadCallback || _createLoadCallback(domain);\r\n        _setIFrameLocation(iFramesObj[domain].elem, src);\r\n        _bindEvent(iFramesObj[domain].elem, \"load\", iFramesObj[domain].loadCallback );//This listens to the onload event of the iFrame\r\n        iFramesObj[domain].iFrameOnloadTimeout = setTimeout(iFramesObj[domain].loadCallback, iFrameOnLoadTimeout);//This sets a timeout in case we did not get the event\r\n        iFramesObj[domain].attachTime =  new Date().getTime();\r\n        document.body.appendChild(iFramesObj[domain].elem);\r\n    }\r\n\r\n    /**\r\n     * Creates the callback for validation of the added iFrame\r\n     * @param domain - the iFrame domain\r\n     */\r\n    function _createLoadCallback( domain){\r\n        return function (eventData) {\r\n            if(iFramesObj[domain].iFrameOnloadTimeout){\r\n                clearTimeout(iFramesObj[domain].iFrameOnloadTimeout);\r\n                delete iFramesObj[domain].iFrameOnloadTimeout;\r\n            }\r\n            iFramesObj[domain].loadTime = new Date().getTime() - iFramesObj[domain].attachTime;\r\n            _validateFrame(domain, eventData);\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Increments our counters of requests made\r\n     */\r\n    function _incrementCallCounters(domain) {\r\n        callCount = callCount + 1;\r\n        pendingCount = pendingCount + 1;\r\n        iFramesObj[domain].requestCount = iFramesObj[domain].requestCount + 1;\r\n    }\r\n\r\n    /**\r\n     * Queues requests for existing iFrames that have not loaded yet\r\n     * @param domain\r\n     * @param msgObj\r\n     * @return {Boolean}\r\n     */\r\n    function _queueForFrame(domain, msgObj) {\r\n        pendingFrameReqQueue[domain] = pendingFrameReqQueue[domain] || [];\r\n        pendingFrameReqQueue[domain].push(msgObj);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Default response when an iFrame is being added\r\n     * and one allready exists for that subdomain\r\n     * @param domain - the domain of the iframe\r\n     * @param success - the callback passed in externally\r\n     * @param context - the context to run the callback in\r\n     * @return {*} - returns a string validated state\r\n     */\r\n    function _frameExists(domain, success, context) {\r\n        var res = getFrameData(domain);\r\n        _runCallBack(success, context, res);\r\n        return iFramesObj[domain].validated;\r\n    }\r\n\r\n    /**\r\n     * Creates an iFrame in memory and sets the default attributes except the actual URL\r\n     * Does not attach to DOM at this point\r\n     * @param id - a passed in ID for easy lookup later\r\n     * @return {Element} - the detached iFrame element\r\n     */\r\n    function _createiFrame(id) {\r\n        var frame = document.createElement(\"IFRAME\");\r\n        frame.setAttribute(\"id\", id);\r\n        frame.setAttribute(\"name\", id);\r\n        frame.setAttribute(\"tabindex\", \"-1\");//To prevent it getting focus when tabbing through the page\r\n        frame.setAttribute(\"aria-hidden\", \"true\");//To prevent it being picked up by screen-readers\r\n        frame.setAttribute(\"title\", \"\");//Adding an empty title at AT&Ts insistence\r\n        frame.setAttribute(\"role\", \"presentation\");//Adding a presentation role http://yahoodevelopers.tumblr.com/post/59489724815/easy-fixes-to-common-accessibility-problems\r\n        frame.style.width = \"0px\";\r\n        frame.style.height = \"0px\";\r\n        frame.style.position = \"absolute\";\r\n        frame.style.top = \"-1000px\";\r\n        frame.style.left = \"-1000px\";\r\n\r\n        return frame;\r\n    }\r\n\r\n    /**\r\n     * Queues a callback for when we get responses from the iFrame\r\n     * @param callId - the UID we sent to the iFrame\r\n     * @param success - the success method passed in\r\n     * @param error - the error method passed in\r\n     * @param progress - the progress method passed in\r\n     * @param context - the execution context for the callbacks\r\n     * @param timeout - the timeout for this request\r\n     * @return {Boolean} - a boolean indicating we queued the request\r\n     */\r\n    function _queueCallback(callId, success, error, progress, context, timeout) {\r\n        var msgQueued = false;\r\n        if (callId && success && typeof success === 'function') {\r\n            callbacks[callId] = { success: success, error: error, progress: progress, ctx: context, launchTime: new Date(), timeout: !isNaN(timeout) ? (timeout + 1000) : rDefaults.timeout };\r\n            msgQueued = true;\r\n        }\r\n        return msgQueued;\r\n    }\r\n\r\n    /**\r\n     * Removes a request from our callback queue\r\n     * @param callId - the identifier of this request\r\n     * @return {Boolean} - if the request was found and de-queued\r\n     */\r\n    function _deQueueCallback(callId) {\r\n        if (callbacks[callId]) {\r\n            callbacks[callId] = null;\r\n            delete callbacks[callId];\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Validation method for an iFrame queued when the iframe fires the load event\r\n     * When this event is triggered it queues the validation request from the internal iFrame\r\n     * with a slight delay, this seems the only way to make it work 100% of the time\r\n     * @param domain - the domain of the iFrame\r\n     * @return {Boolean}\r\n     */\r\n    function _validateFrame(domain, eventData) {\r\n        _log(\"onLoad validation called \" +  domain , logType.INFO, \"_validateFrame\");\r\n        var callback = function (data) {\r\n            _validateFrameCallback(data, domain);\r\n        };\r\n        if(eventData && eventData.error){//This is if a timeout called this method, in that case there is no need to try and talk to the frame - we know it failed\r\n            _validateFrameCallback(eventData, domain);\r\n        }else{\r\n            setTimeout(function () {\r\n                issueCall({ domain: domain,\r\n                        success: callback,\r\n                        error: callback,\r\n                        validation: true,\r\n                        timeout: 100,\r\n                        retries: -1,\r\n                        defaults: iFramesObj[domain].defaults\r\n                    }); }, 10);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Callback function to validate a frame has loaded\r\n     * It can also run a success/error function to notify the frame load outcome\r\n     * This also triggers errors or issues any pending calls in the order\r\n     * @param data\r\n     * @param domain\r\n     * @return {*}\r\n     */\r\n    function _validateFrameCallback(data, domain) {\r\n        var frameLoaded;\r\n        var frame = iFramesObj[domain];//Reference for callbacks after cleanup\r\n        _log(\"running validation of domain \" +  domain , logType.INFO, \"_validateFrameCallback\");\r\n        if (frame) {\r\n            iFramesObj[domain].validated = data && data.error ? validationState.FAILED : validationState.VALIDATED;\r\n            frameLoaded = (iFramesObj[domain].validated === validationState.VALIDATED);\r\n            if(frameLoaded){\r\n                _runFrameValidated(domain, data);\r\n            }else if(iFramesObj[domain].reloadObj && iFramesObj[domain].reloadObj.retriesLeft > 0){\r\n                _runReloadAttempt(domain);\r\n            }else{\r\n                _runFrameFailedToLoad(domain);\r\n            }\r\n        }\r\n        frame = null;\r\n        return frameLoaded;\r\n    }\r\n\r\n    /**\r\n     * Executes when a frame has been loaded successfully and can now be used for communication\r\n     * @param domain\r\n     */\r\n    function _runFrameValidated(domain, data){\r\n        var res;\r\n        _log(\"FrameLoaded \" +  domain , logType.INFO, \"_runFrameValidated\");\r\n        res = _cloneSimpleObj(iFrameLoaded);\r\n        for(var key in data){\r\n            if(data.hasOwnProperty(key)) {\r\n                res[key] = data[key];\r\n            }\r\n        }\r\n        _runCallBack(iFramesObj[domain].success, iFramesObj[domain].context, res);\r\n        _cleanUpReloadObject(domain);\r\n        _runQueuedRequests(domain, true);\r\n    }\r\n\r\n    /**\r\n     * Runs when a frame has failed to load and we need to clean it up along\r\n     * with any pending requests\r\n     * @param domain\r\n     */\r\n    function _runFrameFailedToLoad(domain){\r\n        _log(\"iFrame is a teapot \" +  domain , logType.ERROR, \"_runFrameFailedToLoad\");\r\n        if(iFramesObj[domain].error){//Work with local pointer\r\n            var errResponse = _getErrorResponse(0, iFrameTeapot);\r\n            errResponse.domain = domain;\r\n            _runCallBack(iFramesObj[domain].error, iFramesObj[domain].context, errResponse );\r\n        }\r\n        _cleanupIFrame(domain);\r\n        _runQueuedRequests(domain, false);\r\n    }\r\n\r\n    /**\r\n     * Executed in case we have a reload state for this iFrame\r\n     * @param domain\r\n     */\r\n    function _runReloadAttempt(domain){\r\n        _log(\"Retry loading domain: \" +  domain , \"info\", \"_runReloadAttempt\");\r\n        _runQueuedRequests(domain, false);\r\n        _handleReload(domain);\r\n    }\r\n\r\n    /**\r\n     * Runs any queued callbacks before the iFrame loaded\r\n     * In the order they were queued\r\n     * @param domain\r\n     * @param frameLoaded\r\n     */\r\n    function _runQueuedRequests(domain,frameLoaded){\r\n        _log(\"Running buffer queue : \" + domain + \" loaded: \" + frameLoaded , logType.INFO , \"_runQueuedRequests\");\r\n        if (pendingFrameReqQueue[domain] && pendingFrameReqQueue[domain].length > 0) {\r\n            do {\r\n                var pending = pendingFrameReqQueue[domain].shift();\r\n                if (frameLoaded) {\r\n                    issueCall(pending);\r\n                } else {\r\n                    _runCallBack(pending.error, pending.context, { responseCode: 600, error: \"Transport - postmessage - unable to run request: \" + domain, body: \"ERROR\" });\r\n                }\r\n            } while (pendingFrameReqQueue[domain].length > 0);\r\n            pendingFrameReqQueue[domain] = null;\r\n            delete pendingFrameReqQueue[domain];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Cleans up the iFrame for a specific domain\r\n     * @param domain\r\n     */\r\n    function _cleanupIFrame(domain){\r\n        _log(\"Cleaning up failed iFrame: \" + domain,  logType.INFO , \"_cleanupIFrame\");\r\n        if(iFramesObj[domain]){\r\n            _unbindEvent(iFramesObj[domain].elem, \"load\",iFramesObj[domain].loadCallback);\r\n            iFramesObj[domain].elem.parentNode.removeChild(iFramesObj[domain].elem);\r\n            var result = _cloneSimpleObj(iFrameTeapot);\r\n            result.domain = domain;\r\n            result.url = iFramesObj[domain].url;\r\n            _runCallBack(iFramesObj[domain].error, iFramesObj[domain].context, result);\r\n            _returnFrameToList(iFramesObj[domain]); //Allow reloading of the same iFrame on next request\r\n            iFramesObj[domain] = null;//Removes the iFrame from the domain map, before callback in case it re-registers a frame\r\n            delete iFramesObj[domain];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Default callback if no iframe was found that can handle the request\r\n     * @param domain\r\n     * @param callback\r\n     * @param context\r\n     * @return {Boolean}\r\n     */\r\n    function _noFrameFound(domain, callback, context) {\r\n        _log(\"Frame not found for domain: \" + domain,  logType.ERROR , \"_noFrameFound\");\r\n        _runCallBack(callback, { responseCode: 600, error: \"Transport - postmessage - unable to run request: \" + domain, body: \"ERROR\" }, context);\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Sends the actual request to the child frame\r\n     * while setting up callbacks\r\n     * @param msgObj\r\n     * @return {Boolean}\r\n     */\r\n    function _sendRequest(msgObj) {\r\n        var msgToSend, msgSent = false;\r\n        msgObj = _setUpMessageObj(msgObj);\r\n        msgToSend = _cloneSimpleObj(msgObj);\r\n        try {\r\n            msgToSend = _stringify(msgToSend);\r\n        } catch (err) {\r\n            _log(\"Error trying to _stringify message\", logType.ERROR, \"sendMessageToFrame\");\r\n            return false;\r\n        }\r\n        _log(\"sending msg to domain \" +  msgObj.domain, logType.DEBUG, \"sendMessageToFrame\");\r\n        var parentTimeout;\r\n        if (!isNaN(msgObj.timeout) && !isNaN(msgObj.retries)) {\r\n            parentTimeout = (msgObj.timeout * (msgObj.retries + 1)) + 2000;\r\n        }\r\n        _queueCallback(msgObj.callId, msgObj.success, msgObj.error, msgObj.progress, msgObj.context, parentTimeout );\r\n        try {\r\n            msgSent = _postTheMessage(msgObj.domain, msgToSend);\r\n            errorTimeOutId = setTimeout(_checkForErrors, 1000);\r\n        }\r\n        catch (err) {\r\n            _log(\"Error trying to send message: \" + err, logType.ERROR, \"sendMessageToFrame\");\r\n            msgSent = false;\r\n        }\r\n        return msgSent;\r\n    }\r\n\r\n    /**\r\n     * This function was added because of incompatibility between the JSON._stringify and Prototype.js library\r\n     * When a costumer uses Prototype.js library, It overrides the Array.prototype.toJSON function the the native JSON\r\n     * uses. This causes arrays to be double quoted and Shark to fail on those SDEs.\r\n     * The function accepts a value and and uses the native JSON._stringify\r\n     * Can throw an exception (same as JSON._stringify).\r\n     */\r\n    function _stringify(value) {\r\n        var stringified;\r\n        if (typeof Array.prototype.toJSON === 'function') {\r\n            var toJSONPrototype = Array.prototype.toJSON;\r\n            delete Array.prototype.toJSON;\r\n            try {\r\n                stringified = JSON.stringify(value);\r\n            } catch (e) {\r\n                Array.prototype.toJSON = toJSONPrototype;\r\n                throw e;\r\n            }\r\n            Array.prototype.toJSON = toJSONPrototype;\r\n        } else {\r\n            stringified = JSON.stringify(value);\r\n        }\r\n        return stringified;\r\n    }\r\n\r\n    /**\r\n     * Sets up the call to have a callId we use to identify the returning message\r\n     * Sets up the callback domain\r\n     * Sets up triggering of progress events if a progress callback was supplied\r\n     * @param msgObj\r\n     * @return {*}\r\n     */\r\n    function _setUpMessageObj(msgObj) {\r\n        var frameConfig = iFramesObj[msgObj.domain] && iFramesObj[msgObj.domain].defaults;\r\n        msgObj.callId = _createUId(\"call\");\r\n        msgObj.returnDomain = docSubDomain;\r\n        if(typeof msgObj.timeout === 'undefined'){\r\n            msgObj.timeout = (frameConfig && frameConfig.timeout) || rDefaults.timeout;\r\n        }\r\n        if(typeof msgObj.retries === 'undefined'){\r\n            msgObj.retries = (frameConfig && typeof frameConfig.retries !== 'undefined') ? frameConfig.retries : rDefaults.retries;\r\n        }\r\n        if (msgObj.progress) {\r\n            msgObj.fireProgress = true;\r\n        }\r\n        msgObj.headers = msgObj.headers || {};\r\n        msgObj.headers[\"LP-URL\"] = window.location.href;\r\n        return msgObj;\r\n    }\r\n\r\n    /**\r\n     * Posts the message to the sub-domain iFrame\r\n     * Increments the counters so we know how many requests were\r\n     * sent to this iFrame\r\n     * @param domain\r\n     * @param msgToSend\r\n     * @return {Boolean}\r\n     */\r\n    function _postTheMessage(domain, msgToSend) {\r\n        var messageSent = false;\r\n        try {\r\n            iFramesObj[domain].elem.contentWindow.postMessage(msgToSend, domain);\r\n            messageSent = true;\r\n        } catch (err) {\r\n            _log(\"Error trying to send message: \" + err, logType.ERROR, \"_postTheMessage\");\r\n        }\r\n        return messageSent;\r\n    }\r\n\r\n    /**\r\n     * Checks for timeout errors on messages we never got replies on\r\n     * @return {Boolean}\r\n     */\r\n    function _checkForErrors() {\r\n        if (errorTimeOutId) {\r\n            clearTimeout(errorTimeOutId);\r\n        }\r\n        errorTimeOutId = null;\r\n        var now = new Date();\r\n        var pendReqCount = 0;\r\n        var timedOutCallbacks = [];\r\n        for (var key in callbacks) {//Check for requests taking too long\r\n            if (callbacks.hasOwnProperty(key) && callbacks[key].launchTime) {\r\n                var timeElapsed = now - callbacks[key].launchTime;\r\n                if (timeElapsed > callbacks[key].timeout) {//Queue error callback\r\n                    timedOutCallbacks.push(key);\r\n                } else {\r\n                    pendReqCount = pendReqCount + 1;\r\n                }\r\n            }\r\n        }\r\n        if(timedOutCallbacks.length){\r\n            _log(\"Checking errors found \" + timedOutCallbacks.length + \" timeout callbacks to call\",  logType.DEBUG , \"_checkForErrors\");\r\n            for (var i = 0; i < timedOutCallbacks.length; i++) {//Execute the callbacks\r\n                _executeMessageCallback(_getErrorResponse(timedOutCallbacks[i], postMessageTimeout));\r\n            }\r\n        }\r\n        if (pendReqCount > 0) {\r\n            errorTimeOutId = setTimeout(_checkForErrors, 1000);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Flat clone method, only clones data ignoring functions\r\n     * @param obj\r\n     * @return {Object}\r\n     */\r\n    function _cloneSimpleObj(obj) {\r\n        var resObj = obj;\r\n\r\n        try{\r\n            resObj = JSON.parse(_stringify(obj));\r\n        }catch(exc){}\r\n\r\n        return resObj;\r\n    }\r\n\r\n    /**\r\n     * Retrieves and triggers the correct callback for\r\n     * the response we got from the iFrame\r\n     * @param data\r\n     * @param origin\r\n     * @return {Boolean}\r\n     */\r\n    function _executeMessageCallback(data, origin) {\r\n        var cbInfo = callbacks[data.callId],\r\n            callBack,\r\n            responseType = data.responseType,\r\n            clearData = false;\r\n\r\n        if ((data.callId && callbacks[data.callId]) ||\r\n            data.responseType === responseTypes.reloading ||\r\n            data.responseType === responseTypes.stats) {\r\n            try {\r\n                switch (responseType) {\r\n                    case responseTypes.completed:\r\n                        callBack = cbInfo.success;\r\n                        clearData = true;\r\n                        break;\r\n                    case responseTypes.error:\r\n                        callBack = cbInfo.error;\r\n                        clearData = true;\r\n                        errorCount = errorCount + 1;\r\n                        break;\r\n                    case responseTypes.progress:\r\n                        callBack = cbInfo.progress;\r\n                        break;\r\n                    case responseTypes.reloading:\r\n                        data = origin;\r\n                        callBack = _handleReload;\r\n                        break;\r\n                    case responseTypes.stats:\r\n                        callBack = _publishMetrics;\r\n                        data = data.rawData;\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n                if (clearData) {\r\n                    _deQueueCallback(data.callId);\r\n                    _cleanRequest(data);\r\n                    pendingCount = pendingCount >= 0 ? 0 : pendingCount - 1;\r\n                }\r\n\r\n                if (callBack && typeof callBack === 'function') {\r\n                    _runCallBack(callBack, (cbInfo && cbInfo.ctx) || null, data);\r\n                }\r\n                callBack = null;\r\n                cbInfo = null;\r\n            } catch (err) {\r\n                _log(\"Error in executing callback: \" + err, logType.ERROR, \"_executeMessageCallback\");\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Handles a case where we identify too\r\n     * many errors from an iframe and need to pause new\r\n     * requests to it\r\n     */\r\n    function _handleReload(origin){\r\n        _log(\"Got reload request from \" + origin, logType.INFO , \"_handleReload\");\r\n        iFramesObj[origin].validated = validationState.PENDING;\r\n        if(!iFramesObj[origin].reloadObj){\r\n            _log(\"Creating reloadObj\" + origin,  logType.DEBUG , \"_handleReload\");\r\n            iFramesObj[origin].reloadObj = _createReloadObject(origin);\r\n        }\r\n        _reloadIFrame(origin);\r\n    }\r\n\r\n    /**\r\n     * Sets the iFrame to reload indicating time and counting down the retries\r\n     * @param domain\r\n     */\r\n    function _reloadIFrame(domain){\r\n        _log(\"Reload try for domain \"  + domain + \" ,retries left \"  + iFramesObj[domain].reloadObj.retriesLeft,  logType.INFO , \"_reloadIFrame\");\r\n        iFramesObj[domain].reloadObj.retriesLeft = iFramesObj[domain].reloadObj.retriesLeft - 1;\r\n        if(iFramesObj[domain].reloadObj.setLocationTimeout){\r\n            clearTimeout(iFramesObj[domain].reloadObj.setLocationTimeout);\r\n        }\r\n        if(iFramesObj[domain].reloadObj.retry){\r\n            iFramesObj[domain].reloadObj.setLocationTimeout =  setTimeout(_createIFrameLocationFunction(domain), iFramesObj[domain].reloadInterval);\r\n        }else{\r\n            iFramesObj[domain].reloadObj.retry = true;\r\n            _createIFrameLocationFunction(domain)();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a function that sets the iFrames src and times a timeout for the reload\r\n     * @param domain\r\n     * @return {Function}\r\n     */\r\n    function _createIFrameLocationFunction(domain){\r\n        return function(){\r\n            iFramesObj[domain].iFrameOnloadTimeout = setTimeout(function(){\r\n                _validateFrame(domain, { error: { code: 404, message: \"Frame did not trigger load\" }});\r\n            }, iFrameOnLoadTimeout);\r\n            _setIFrameLocation(iFramesObj[domain].elem,iFramesObj[domain].url);\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Sets the iFrame location using a cache bust mechanism,\r\n     * making sure the iFrame is actually loaded and not from cache\r\n     * @param element\r\n     * @param src\r\n     */\r\n    function _setIFrameLocation(element, src){\r\n        src += (src.indexOf(\"?\") > 0 ? \"&bust=\" : \"?bust=\");\r\n        src += new Date().getTime();\r\n        src += \"&loc=\" + encodeURIComponent(location.protocol + \"//\" + location.host);\r\n        _log(\"Setting iFrame to URL: \" + src, logType.INFO, \"_setIFrameLocation\");\r\n        element.setAttribute(\"src\", src);\r\n    }\r\n\r\n    /**\r\n     * Creates the retry object for the retry session\r\n     * @param domain\r\n     * @return {Object}\r\n     */\r\n    function _createReloadObject(domain){\r\n        _log(\"Creating reload object \" + domain,  logType.INFO , \"_createReloadObject\");\r\n        var retryCount = iFramesObj[domain].maxReloadRetries;\r\n        return {\r\n            retriesLeft : retryCount\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Cleans up the transient reload object\r\n     * @param domain\r\n     */\r\n    function _cleanUpReloadObject(domain){\r\n        _log(\"Cleaning up reload object for this instance\" + domain,  logType.INFO , \"_cleanUpReloadObject\");\r\n        if(iFramesObj[domain].reloadObj){\r\n            if(iFramesObj[domain].reloadObj.setLocationTimeout){\r\n                clearTimeout(iFramesObj[domain].reloadObj.setLocationTimeout);\r\n            }\r\n            iFramesObj[domain].reloadObj = null;\r\n            delete iFramesObj[domain].reloadObj;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes any properties we set on the original request\r\n     * Cleanup\r\n     * @param reqObj\r\n     */\r\n    function _cleanRequest(reqObj) {\r\n        var properties = [\"callId\", \"responseType\"];\r\n        for (var i = 0; i < properties.length; i++) {\r\n            reqObj[properties[i]] = null;\r\n            delete reqObj[properties[i]];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Protected method for executing callbacks\r\n     * @param func\r\n     * @param context\r\n     * @param data\r\n     */\r\n    function _runCallBack(func, context, data) {\r\n        if (func && typeof func === 'function') {\r\n            try {\r\n                func.call(context || null, data);\r\n            } catch (err) {\r\n                _log(\"Error in executing callback: \" + err, logType.ERROR, \"runCallback\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles messages from the iFrames\r\n     * @param messageEvent\r\n     */\r\n    function _handleMessage(messageEvent) {\r\n        var result, origin;\r\n        try {\r\n            origin = messageEvent.origin;\r\n            if(!iFramesObj[origin]){//This frame isn't ours! we don't want to know what it's doing!\r\n                return;\r\n            }\r\n            result = _parseJSONString(messageEvent.data);\r\n            result.body = _parseJSONString(result.body);//Workaround for APIs that don't return JSON properly but return strings....\r\n        } catch (exc) {\r\n            result = null;\r\n            _log(\"Error in handling message from frame:\"  + exc + \" origin: \" + origin, logType.ERROR, \"_handleMessage\");\r\n        }\r\n\r\n        if (result && typeof result === 'object') {\r\n            _executeMessageCallback(result, origin);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if it actually got a string and tries to parse it\r\n     * @param str\r\n     * @returns {*}\r\n     */\r\n    function _parseJSONString(str){\r\n        var res = str;\r\n        if(typeof  str === 'string') {\r\n            try {\r\n                res = JSON.parse(str);\r\n            }catch (exc){\r\n                _log(\"Error in parsing string: \" + str ,logType.DEBUG, \"_parseJSONString\");\r\n            }\r\n        }\r\n        \r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Method for logging\r\n     * @param msg\r\n     * @param type\r\n     * @param callingMethod\r\n     */\r\n    function _log(msg, type, callingMethod) {\r\n        if (window.lpTag && lpTag.log) {\r\n            if(typeof msg === 'string' && callingMethod){\r\n                msg = callingMethod + ': ' + msg;\r\n            }\r\n            lpTag.log(msg, type, transportType);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Publishes stats to lpAjax to decide if we want to report this\r\n     * @param domain\r\n     * @param data\r\n     */\r\n    function _publishMetrics(data){\r\n        if(lpTag.taglets.lpAjax && lpTag.taglets.lpAjax.publishMetrics){\r\n            if(data.tags && data.tags.constructor === Array){\r\n                data.tags.push({ transport: transportType });\r\n            }\r\n            lpTag.taglets.lpAjax.publishMetrics(data);\r\n        }\r\n    }\r\n\r\n    //Exposed API\r\n    var publicAPI = {\r\n        v: version,\r\n        name: transportType,\r\n        init: init,\r\n        issueCall: issueCall,\r\n        isValidRequest: isValidRequest,\r\n        getVersion: function () { return version; },\r\n        getName: function () { return transportType; },\r\n        configure: configure,\r\n        getFrameData: getFrameData,\r\n        inspect: function () {\r\n            return {\r\n                name: transportType,\r\n                version: version,\r\n                callsMade: callCount,\r\n                errorsFound: errorCount,\r\n                pending: pendingCount,\r\n                defaults: rDefaults,\r\n                iFrameList: _cloneSimpleObj(iFrameList),\r\n                activeFrames: getAllFramesData()\r\n            };\r\n        }\r\n    };\r\n\r\n    /******************* Initialise public API ********************/\r\n\r\n    init();\r\n\r\n    return publicAPI;\r\n})(window);\r\n\r\n/**\r\n * User: michaeld\r\n * This taglet wraps lpajax taglet with the relevant transports (jsonp + postmessage).\r\n * We do this because lpTag can only call one init function, and this taglet will call init on all other taglets.\r\n */\r\nwindow.lpTag = lpTag || {};\r\nlpTag.taglets = lpTag.taglets || {};\r\n\r\nlpTag.taglets.lpTransporter = lpTag.taglets.lpTransporter || (function () {\r\n\r\n    var _name = \"lpTransporter\";\r\n    var _v = \"1.1.0\";\r\n\r\n    var _conf = {\r\n        taglets: ['lpAjax' ,'lpajax_utils', 'jsonp', 'postmessage']\r\n    };\r\n\r\n    function _log(msg, lvl) {\r\n        if (window.lpTag && lpTag.log) {\r\n            lpTag.log(msg, lvl, _name);\r\n        }\r\n    }\r\n\r\n    function init(cfg) {\r\n\r\n        for (var i = 0; i < _conf.taglets.length; i++) {\r\n            var tgl = lpTag.taglets[_conf.taglets[i]];\r\n            try {\r\n                tgl.init();\r\n                _log('Called init on taglet: ' + _conf.taglets[i], 'DEBUG');\r\n            }\r\n            catch (e) {\r\n                _log('Error init taglet:' + _conf.taglets[i] + '  e=' + e, 'ERROR');\r\n            }\r\n        }\r\n\r\n        for (var j = 0; i < _conf.taglets.length; j++) {\r\n            var tglt = lpTag.taglets[_conf.taglets[j]];\r\n            try {\r\n                if ((typeof (tglt.start) === 'function')) {\r\n                    tglt.start();\r\n                }\r\n                _log('Called start on taglet: ' + _conf.taglets[j], 'DEBUG');\r\n            }\r\n            catch (e) {\r\n                _log('Error start taglet: ' + _conf.taglets[j] + 'e= ' + e, 'ERROR');\r\n            }\r\n        }\r\n    }\r\n\r\n    return {\r\n        v: _v,\r\n        name: _name,\r\n        init: init\r\n    };\r\n\r\n})();","parameters":null}],"retry":false});